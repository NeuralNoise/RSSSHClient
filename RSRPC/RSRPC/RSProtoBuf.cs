using System;
using System.Text;
using System.IO;
using System.Collections.Generic;
using System.Threading;

using ProtoBuf;

using rsctrl.core;

using Renci.SshNet;

/*
    [HEADER: 16 bytes: 4 x Network Order uint32_t][ VARIABLE LENGTH BODY ] 
    [ MAGIC_CODE ] [ MSG_ID ] [ REQ_ID ] [ BODY_SIZE ] [ ..... BODY ..... ]

    MagicCode = 0x137f0001. will be incremented for new versions of the protocol.
    MsgID = Corresponds to the format of the Body.
    ReqID = Generated by Requester, Returned in Response, make sure its unique. (undefined behaviour for duplicates)
    BodySize = Byte Length of Body.

    The Body will consist of a protobuf encoded message.
 */

namespace Sehraf.RSRPC
{
    /// <summary>
    /// Structure containing everything needed for a RPC call
    /// </summary>
    public struct RSProtoBuffSSHMsg
    {
        private const uint _magicCode = 0x137f0001;
        public const byte _headerSize = 16;

        private uint _msgID, _reqID, _bodySize;
        Stream _pbMsg;

        public uint MagicCode { get { return _magicCode; } }
        public uint MsgID { get { return _msgID; } set { _msgID = value; } }
        public uint ReqID { get { return _reqID; } set { _reqID = value; } }
        public uint BodySize { get { return _bodySize; } set { _bodySize = value; } }
        public Stream ProtoBuffMsg { get { return _pbMsg; } set { _pbMsg = value; } }
    }

    /// <summary>
    /// Compare two persons by name
    /// </summary>
    public class PersonComparer : IComparer<Person>
    {
        public int Compare(Person p1, Person p2)
        {
            return p1.name.CompareTo(p2.name);
        }
    }

    public class RSProtoBuf
    {
        const bool DEBUG = false;

        ShellStream _stream;
        uint _nextReqID, _timeOut, _lastSize;
        ushort _readSpeed = 100; // KiB/s
        RSRPC _parent;

        Queue<RSProtoBuffSSHMsg> _sendQueue;
        Queue<RSProtoBuffSSHMsg> _receiveQueue;

        Thread _t;
        bool _run, _finishQueue, _findMagicCode;

        public bool ThreadRunning { get { return _t.IsAlive; } }
        public ushort ReadSpeed { get { return _readSpeed; } set { _readSpeed = value; } }

        public RSProtoBuf(ShellStream stream, Queue<RSProtoBuffSSHMsg> sendQueue, Queue<RSProtoBuffSSHMsg> receiveQueue, RSRPC parent, uint timeout = 1000, bool useThread = true)
        {
            _stream = stream;

            _nextReqID = 1;
            _timeOut = timeout;
            _sendQueue = sendQueue;
            _receiveQueue = receiveQueue;
            _parent = parent;

            if (useThread)
            {
                _run = true;
                _finishQueue = false;
                _findMagicCode = false;
                _t = new Thread(new ThreadStart(mainLoop));
                _t.Priority = ThreadPriority.AboveNormal;
                _t.Name = "RS Send/Recieve loop";
                _t.Start();
            }
        }

        /// <summary>
        /// Wrtites a msg to the SSH stream
        /// </summary>
        /// <param name="msg">msg to send</param>
        /// <returns></returns>
        public uint Send(RSProtoBuffSSHMsg msg)
        {
            System.Diagnostics.Debug.WriteLineIf(DEBUG, "send: sending packet " + msg.ReqID + " MsgID: " + msg.MsgID + " body size: " + msg.BodySize);
            if (_stream.CanWrite)
            {
                try
                {
                    _stream.Write(CreatePacketFromMsg(msg), 0, 16 + (int)msg.BodySize);
                    _stream.Flush();
                }
                catch (Exception e)
                {
                    _parent.Error(e);
                }
            }
            else
            {
                System.Diagnostics.Debug.WriteLine("send: can't write stream");
                _parent.Error(new IOException("send: can't write stream"));
            }

            return msg.ReqID;
        }

        /// <summary>
        /// breaks the SSH connecting by sending a wrong packet
        /// temporary solution
        /// </summary>
        public void BreakConnection()
        {
            _stream.Write("disconnect");
        }

        /// <summary>
        /// wrapper for ReadMsgFromStream(..)
        /// </summary>
        /// <param name="msg">RSProtoBuffSSHMsg (out)</param>
        /// <param name="timeOut">timeout in ms ( 0 = default)</param>
        /// <returns>success?</returns>
        public bool Receive(out RSProtoBuffSSHMsg msg, uint timeOut = 0)
        {
            msg = new RSProtoBuffSSHMsg();
            if (!_stream.CanRead)
            {
                System.Diagnostics.Debug.WriteLine("rec: cannot read stream!");
                _parent.Error(new IOException("send: can't read stream"));
                return false;
            } 
            if (!ReadMsgFromStream(ref msg, timeOut))
            {
                System.Diagnostics.Debug.WriteLine("rec: Error receiving data from stream");                
                return false;
            }

            System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: " + msg.ReqID + " body Length: " + msg.ProtoBuffMsg.Length);
            return true;
        }

        /// <summary>
        /// Contructs a msg from the SSH stream
        /// </summary>
        /// <param name="msg">RSProtoBuffSSHMsg (ref)</param>
        /// <param name="timeOut">timeout in ms ( 0 = default)</param>
        /// <param name="GetHeader">read header or skip to ProtoBufMsg</param>
        /// <returns>success?</returns>
        private bool ReadMsgFromStream(ref RSProtoBuffSSHMsg msg, uint timeOut = 0, bool GetHeader = true)
        {
            if (timeOut == 0)
                timeOut = _timeOut;

            byte[] input = new byte[16], buffer;
            uint magicCode;

            if (GetHeader)
            {
                // get Header
                if (!ReadFromStream(timeOut, 16, out buffer))
                    return false;
                buffer.CopyTo(input, 0);

                // read header
                Array.Reverse(input);
                msg.BodySize = BitConverter.ToUInt32(input, 0);
                msg.ReqID = BitConverter.ToUInt32(input, 4);
                msg.MsgID = BitConverter.ToUInt32(input, 8);
                magicCode = BitConverter.ToUInt32(input, 12);

                System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: ReqID: " + msg.ReqID + " - MsgID: " + msg.MsgID + " - body size: " + msg.BodySize + " byte");

                if (magicCode != msg.MagicCode)
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: MagicCode mismatch");
                    _findMagicCode = true;
                    _lastSize = msg.BodySize;
                    _parent.Error(new Exception("MagicCode mismatch"));
                    return false;
                }

                if (!IsRpcMsgIdResponse(msg.MsgID))
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: msg is no response");
            }
            else
                System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: ReqID: " + msg.ReqID + " - MsgID: " + msg.MsgID + " - body size: " + msg.BodySize + " byte");

            // get ProtoBufMsg
            byte[] PbMsg = new byte[msg.BodySize];
            if (!ReadFromStream(timeOut, (int)msg.BodySize, out buffer))
                return false;
            buffer.CopyTo(PbMsg, 0);

            msg.ProtoBuffMsg = new MemoryStream();
            msg.ProtoBuffMsg.Write(PbMsg, 0, (int)msg.BodySize);
            msg.ProtoBuffMsg.Position = 0;
            return true;
        }

        /// <summary>
        /// Reads bytes from the SSH stream
        /// </summary>
        /// <param name="timeOut">timeout in ms</param>
        /// <param name="length">how many bytes</param>
        /// <param name="output">byte array (out)</param>
        /// <returns>success?</returns>
        private bool ReadFromStream(uint timeOut, int length, out byte[] output)
        {
            bool done = false;
            ushort bufferLength = 512, sleepTime = 1; // ~100KiB/s
            switch (_readSpeed)
            {
                case 0:
                default:
                    break;
                case 10:
                    bufferLength = 512; sleepTime = 50; // ~10KiB/s
                    break;
                case 20:
                    bufferLength = 1024; sleepTime = 50; // ~20KiB/s
                    break;
                case 50:
                    bufferLength = 512; sleepTime = 10; // ~50KiB/s
                    break;
                case 100:
                    bufferLength = 512; sleepTime = 5; // ~100KiB/s
                    break;
                case 500:
                    bufferLength = 512; sleepTime = 1; // ~500KiB/s
                    break;                
            }
            uint read = 0;
            ushort toRead;
            byte[] buffer = new byte[bufferLength];
            output = new byte[length];
            
            DateTime timeOutTime = DateTime.Now.AddMilliseconds(timeOut);
            while (DateTime.Now < timeOutTime && !done)
            {
                if (_stream.DataAvailable)
                {
                    try
                    {
                        while (_stream.DataAvailable && length > read)
                        {
                            toRead = (ushort)((length - read > bufferLength) ? bufferLength : length - read);
                            _stream.Read(buffer, 0, toRead);
                            Array.Copy(buffer, 0, output, read, toRead);
                            read += toRead;

                            Thread.Sleep(sleepTime);
                        }
                        if (read == length)
                            done = true;

                        // we got data - reset timeout
                        timeOutTime = DateTime.Now.AddMilliseconds(timeOut);
                    }
                    catch (Exception e)
                    {
                        _parent.Error(e);
                    }
                }
                else
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: Stream to short (" + length + ") ... waiting (" + (timeOutTime - DateTime.Now).TotalMilliseconds + ")");
                    System.Threading.Thread.Sleep(250);
                }
            }
            if (!done)
            {
                System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: Could not get header");
                return false;
            }
            return true;
        }

        /// <summary>
        /// Converts a msg into a a byte array in network order (ready to send)
        /// </summary>
        /// <param name="msg">input RSProtoBuffSSHMsg to convert</param>
        /// <returns>msg as a byte array</returns>
        private byte[] CreatePacketFromMsg(RSProtoBuffSSHMsg msg)
        {
            byte[] a = new byte[4];
            byte[] pbMsg = new byte[msg.BodySize];
            byte[] output = new byte[16 + msg.BodySize];

            a = UintToByteNetwortOrder(msg.MagicCode);
            Array.Copy(a, 0, output, 0, 4);
            a = UintToByteNetwortOrder(msg.MsgID);
            Array.Copy(a, 0, output, 4, 4);
            a = UintToByteNetwortOrder(msg.ReqID);
            Array.Copy(a, 0, output, 8, 4);
            a = UintToByteNetwortOrder(msg.BodySize);
            Array.Copy(a, 0, output, 12, 4);

            msg.ProtoBuffMsg.Read(pbMsg, 0, (int)msg.BodySize);
            msg.ProtoBuffMsg.Position = 0;
            Array.Copy(pbMsg, 0, output, 16, (int)msg.BodySize);

            return output;
        }

        /// <summary>
        /// Converts an unsigned integer (uint) into a byte array in network order
        /// </summary>
        /// <param name="i">unsigned integer to convert</param>
        /// <returns>unsigned integer converted to byte array</returns>
        private byte[] UintToByteNetwortOrder(uint i)
        {
            byte[] a = new byte[4];
            a = BitConverter.GetBytes(i);
            Array.Reverse(a);
            return a;
        }

        /// <summary>
        /// Generates a request ID by adding 1 to the last ID
        /// </summary>
        /// <returns>request ID</returns>
        public uint GetReqID()
        {
            if (_nextReqID < UInt32.MaxValue)
                return _nextReqID++;

            _nextReqID = 0; // else
            return _nextReqID;
        }

        /// <summary>
        /// Main loop to send and receive data from the SSH stream.
        /// 
        /// Takes msgs from _sendQueue and sends them.
        /// Reads msgs and put them in _receiveQueue for further processing.
        /// Also reconnects when "MagicCode missmatch" occurs.
        /// 
        /// Is designed to run in an own thread.
        /// Use _run = false to stop the loop.
        /// Use _finishQueue to send al pending msgs ( won't receive data anymore )
        /// </summary>
        private void mainLoop()
        {
            bool foundWork;
            byte[] header1 = new byte[4], header234 = new byte[12], buffer = new byte[1024 * 25];
            RSProtoBuffSSHMsg msg = new RSProtoBuffSSHMsg(), newMsg = new RSProtoBuffSSHMsg();
            while (_run)
            {
                foundWork = false;
                if (_stream.DataAvailable && _run && !_finishQueue && !_findMagicCode)
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "#######################################");
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: receiving");
                    if (Receive(out newMsg))
                        lock (_receiveQueue)
                            _receiveQueue.Enqueue(newMsg);
                    foundWork = true;
                }

                if (_stream.DataAvailable && _findMagicCode)
                {
                    if (!_parent.Reconnect(out _stream))
                    {
                        _parent.Error(new Exception("Error while reconnecting"));
                        _run = false;
                    }
                    else 
                        _findMagicCode = false;

                    /*
                     * this doesn't work yet 
                     * the idea is to search for the next MagicCode assuming it's the begin of a new msg
                     * but this produce some strange behavior, is very slow and unreliable
                     */

                    //System.Diagnostics.Debug.WriteLineIf(DEBUG, "#######################################");
                    //System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: trying to find Magic Code ...");

                    //for (short i = 0; i < 1024 * 25 / 4; i++) // 25k too much? 
                    //{
                    //    if (!_stream.DataAvailable)
                    //        break;
                    //    if (!ReadFromStream(_timeOut, 4, out header1))
                    //        break;
                    //    //buffer.CopyTo(header1, 0);
                    //    Array.Reverse(header1);
                    //    if (BitConverter.ToUInt32(header1, 0) == msg.MagicCode)
                    //    {
                    //        System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: found Magic Code");

                    //        // found magic code -> try to receive whole msg
                    //        if (!ReadFromStream(_timeOut, 12, out header234))
                    //            break;
                    //        //buffer.CopyTo(header234, 0);
                    //        Array.Reverse(header234);
                    //        newMsg.BodySize = BitConverter.ToUInt32(header234, 0);
                    //        newMsg.ReqID = BitConverter.ToUInt32(header234, 4);
                    //        newMsg.MsgID = BitConverter.ToUInt32(header234, 8);

                    //        System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: ReqID: " + msg.ReqID + " - MsgID: " + msg.MsgID + " - body size: " + msg.BodySize + " byte");

                    //        if (!IsRpcMsgIdResponse(msg.MsgID))
                    //        {
                    //            // is no response ( the magic code was a wrong one - or the response was somehow broken )
                    //            System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: no response");
                    //            continue;
                    //        }

                    //        if (ReadMsgFromStream(msg: ref newMsg, GetHeader: false))
                    //        {
                    //            // there is nothing more we can do here ... just put the msg in the queue and hope the best :D
                    //            System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: received msg");
                    //            lock (_receiveQueue)
                    //                _receiveQueue.Enqueue(newMsg);
                    //            _findMagicCode = false;
                    //            break;
                    //        }
                    //        else
                    //            System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: couldn't get msg");
                    //    }
                    //} // for
                    //foundWork = true;
                }

                if (_sendQueue.Count > 0)
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "#######################################");
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: sending req");
                    lock (_sendQueue)
                        msg = _sendQueue.Dequeue();
                    Send(msg);
                    foundWork = true;
                }

                if (!foundWork && _run && !_finishQueue)
                    System.Threading.Thread.Sleep(250);

                if (_finishQueue && _sendQueue.Count == 0)
                    _run = false;
            }
        }

        /// <summary>
        /// Function to prepare the main loop to stop ( sets _finishQueue = true )
        /// </summary>
        public void FinishQueue()
        {
            _finishQueue = true;
        }

        /// <summary>
        /// Stops the main loop ( using Thread.Abort() )
        /// </summary>
        public void StopThread()
        {
            _run = false;
            _t.Abort();
        }

        // MsgID functions
        // Lower 8 bits.
        public static byte GetRpcMsgIdSubMsg(uint msgID)
        {
            return BitConverter.GetBytes(msgID)[0];
        }

        // Middle 16 bits.
        public static ushort GetRpcMsgIdService(uint msgID)
        {
            return BitConverter.ToUInt16(BitConverter.GetBytes(msgID), 1);
        }

        // Top 8 bits.
        public static byte GetRpcMsgIdExtension(uint msgID)
        {
            return (byte)(BitConverter.GetBytes(msgID)[3] & 0xFE);
            //return (msg_id >> 24) & 0xFE; // Bottom Bit is for Request / Response
        }

        public static bool IsRpcMsgIdResponse(uint msgID)
        {
            return ((BitConverter.GetBytes(msgID)[3] & 0x01) > 0 ? true : false);
            //return (msg_id >> 24) & 0x01;
        }

        public static uint ConstructMsgId(byte ext, ushort service, byte submsg, bool isResponse)
        {
            if (isResponse)
                ext |= 0x01; // Set Bottom Bit.
            else
                ext &= 0xFE; // Clear Bottom Bit.
            int msg_id = (ext << 24) + (service << 8) + (submsg);
            return Convert.ToUInt32(msg_id);
        }

        public static string GetHex(uint msgID)
        {
            return Convert.ToString(msgID, 16);
        }

        public static string GetHex(byte msgID)
        {
            return Convert.ToString(msgID, 16);
        }

        /// <summary>
        /// Wrapper with error handling for deserialisation
        /// </summary>
        /// <typeparam name="T">type of msg</typeparam>
        /// <param name="body">stream containing the msg</param>
        /// <param name="msg">msg (out) is default(T) if an error occurs</param>
        /// <param name="e">error (out) contains the error if any occurs</param>
        /// <returns>success?</returns>
        public static bool Deserialize<T>(Stream body, out T msg, out Exception e)
        {
            try
            {                
                msg = Serializer.Deserialize<T>(body);
                e = null;
                return true;
            }
            catch (Exception exc)
            {
                e = exc;
                msg = default(T);
                return false;
            }
        }
    }
}
