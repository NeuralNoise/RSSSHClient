using System;
using System.Text;
using System.IO;
using System.Collections.Generic;
using System.Threading;

using ProtoBuf;

//using Renci.SshNet;
//using Renci.SshNet.Common;

using rsctrl.core;
//using rsctrl.peers;

using Renci.SshNet;

//[HEADER: 16 bytes: 4 x Network Order uint32_t][ VARIABLE LENGTH BODY ] 
//[ MAGIC_CODE ] [ MSG_ID ] [ REQ_ID ] [ BODY_SIZE ] [ ..... BODY ..... ]

//MagicCode = 0x137f0001. will be incremented for new versions of the protocol.
//MsgID = Corresponds to the format of the Body.
//ReqID = Generated by Requester, Returned in Response, make sure its unique. (undefined behaviour for duplicates)
//BodySize = Byte Length of Body.

//The Body will consist of a protobuf encoded message.

namespace Sehraf.RSRPC
{
    public struct RSProtoBuffSSHMsg
    {
        private const uint _magicCode = 0x137f0001;
        public const byte _headerSize = 16;

        private uint _msgID, _reqID, _bodySize;
        Stream _pbMsg;
        //bool _important;

        public uint MagicCode { get { return _magicCode; } }
        public uint MsgID { get { return _msgID; } set { _msgID = value; } }
        public uint ReqID { get { return _reqID; } set { _reqID = value; } }
        public uint BodySize { get { return _bodySize; } set { _bodySize = value; } }
        public Stream ProtoBuffMsg { get { return _pbMsg; } set { _pbMsg = value; } }
        //public bool IsImportant { get { return _important; } set { _important = value; } }
    }

    public class PersonComparer : IComparer<Person>
    {
        public int Compare(Person p1, Person p2)
        {
            return p1.name.CompareTo(p2.name);
        }
    }

    public class RSProtoBuf
    {
        const bool DEBUG = false;

        ShellStream _stream;
        uint _nextReqID;
        uint _timeOut;
        RSRPC _parent;

        Queue<RSProtoBuffSSHMsg> _sendQueue;
        Queue<RSProtoBuffSSHMsg> _receiveQueue;

        Thread _t;
        bool _run, _finishQueue;

        public bool ThreadRunning { get { return _t.IsAlive; } }

        public RSProtoBuf(ShellStream stream, Queue<RSProtoBuffSSHMsg> sendQueue, Queue<RSProtoBuffSSHMsg> receiveQueue, RSRPC parent, uint timeout = 1000, bool useThread = true)
        {
            _stream = stream;

            _nextReqID = 1;
            _timeOut = timeout;
            _sendQueue = sendQueue;
            _receiveQueue = receiveQueue;
            _parent = parent;

            if (useThread)
            {
                _run = true;
                _finishQueue = false;
                _t = new Thread(new ThreadStart(mainLoop));
                _t.Priority = ThreadPriority.AboveNormal;
                _t.Name = "RS Send/Recieve loop";
                _t.Start();
            }
        }

        public uint Send(RSProtoBuffSSHMsg msg)
        {
            System.Diagnostics.Debug.WriteLineIf(DEBUG, "send: sending packet " + msg.ReqID + " MsgID: " + msg.MsgID + " body size: " + msg.BodySize);
            if (_stream.CanWrite)
            {
                try
                {
                    _stream.Write(CreatePacketFromMsg(msg), 0, 16 + (int)msg.BodySize);
                    _stream.Flush();
                }
                catch (Exception e)
                {
                    _parent.Error(e);
                }
            }
            else
            {
                System.Diagnostics.Debug.WriteLine("send: can't write stream");
                _parent.Error(new IOException("send: can't write stream"));
            }

            return msg.ReqID;
        }

        // temporary solution
        public void BreakConnection()
        {
            _stream.Write("disconnect");
            //_stream.Flush();
        }

        public bool Receive(out RSProtoBuffSSHMsg msg, uint timeOut = 0)
        {
            msg = new RSProtoBuffSSHMsg();
            //if (!_streamOut.CanRead) 
            if (!_stream.CanRead)
            {
                System.Diagnostics.Debug.WriteLine("rec: cannot read stream!");
                _parent.Error(new IOException("send: can't read stream"));
                return false;
            } 
            if (!ReadMsgFromStream(ref msg, timeOut))
            {
                System.Diagnostics.Debug.WriteLine("rec: Error receiving data from stream");                
                return false;
            }

            System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: " + msg.ReqID + " body Length: " + msg.ProtoBuffMsg.Length);
            return true;
        }
        
        private bool ReadMsgFromStream(ref RSProtoBuffSSHMsg msg, uint timeOut = 0)
        {
            if (timeOut == 0)
                timeOut = _timeOut;

            byte[] input = new byte[16], buffer;
            //bool done = false;

            // get Header
            if (!ReadFromStream(timeOut, 16, out buffer))            
                return false;            
            buffer.CopyTo(input, 0);

            // read header
            Array.Reverse(input);
            msg.BodySize = BitConverter.ToUInt32(input, 0);
            msg.ReqID = BitConverter.ToUInt32(input, 4);
            msg.MsgID = BitConverter.ToUInt32(input, 8);
            uint magicCode = BitConverter.ToUInt32(input, 12);
            System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: ReqID: " + msg.ReqID + " - MsgID: " + msg.MsgID + " - body size: " + msg.BodySize + " byte");

            if (magicCode != msg.MagicCode)
            {
                System.Diagnostics.Debug.WriteLine("rec: MagicCode mismatch -> returning");
                _parent.Error(new Exception("MagicCode mismatch"));
                return false;
            }

            // get ProtoBufMsg
            //timeOutTime = DateTime.Now.AddMilliseconds(timeOut);
            //done = false;
            //byte[] PbMsg = new byte[msg.BodySize], buffer = new byte[1024];
            //uint read = 0;
            //ushort toread;
            //while (DateTime.Now < timeOutTime && !done)
            //{
            //    if (_stream.DataAvailable)
            //    {
            //        try
            //        {
            //            while (_stream.DataAvailable && msg.BodySize > read )
            //            {
            //                toread = (ushort)((msg.BodySize - read > 1024) ? 1024 : msg.BodySize - read);
            //                _stream.Read(buffer, 0, toread);
            //                Array.Copy(buffer, 0, PbMsg, read, toread);
            //                read += toread;

            //                Thread.Sleep(100);
            //            }
            //            if(read == msg.BodySize )
            //                done = true;

            //            // we got data 
            //            timeOutTime = DateTime.Now.AddMilliseconds(timeOut);
            //        }
            //        catch (Exception e)
            //        {
            //            _parent.Error(e);
            //        }    
            //    }
            //    else
            //    {
            //        System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: Stream to short (body) ... waiting");
            //        System.Threading.Thread.Sleep(100);
            //    }
            //}
            //if (!done)
            //{
            //    System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: Coudl not get body (" + msg.BodySize + ")");
            //    return false;
            //}
            byte[] PbMsg = new byte[msg.BodySize];
            if (!ReadFromStream(timeOut, (int)msg.BodySize, out buffer))
                return false;
            buffer.CopyTo(PbMsg, 0);

            msg.ProtoBuffMsg = new MemoryStream();
            msg.ProtoBuffMsg.Write(PbMsg, 0, (int)msg.BodySize);
            msg.ProtoBuffMsg.Position = 0;
            return true;
        }

        private bool ReadFromStream(uint timeOut, int length, out byte[] output)
        {
            bool done = false;
            ushort bufferLength = 512;
            uint read = 0;
            ushort toRead;
            byte[] buffer = new byte[bufferLength];
            output = new byte[length];
            
            DateTime timeOutTime = DateTime.Now.AddMilliseconds(timeOut);
            while (DateTime.Now < timeOutTime && !done)
            {
                if (_stream.DataAvailable)
                {
                    //try
                    //{
                    //    _stream.Read(output, 0, length);
                    //    done = true;
                    //    break;
                    //}
                    //catch (Exception e)
                    //{
                    //    _parent.Error(e);
                    //}
                    try
                    {
                        while (_stream.DataAvailable && length > read)
                        {
                            toRead = (ushort)((length - read > bufferLength) ? bufferLength : length - read);
                            _stream.Read(buffer, 0, toRead);
                            Array.Copy(buffer, 0, output, read, toRead);
                            read += toRead;

                            Thread.Sleep(50);
                        }
                        if (read == length)
                            done = true;

                        // we got data 
                        timeOutTime = DateTime.Now.AddMilliseconds(timeOut);
                    }
                    catch (Exception e)
                    {
                        _parent.Error(e);
                    }
                }
                else
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: Stream to short (" + length + ") ... waiting (" + (DateTime.Now - timeOutTime).Milliseconds + ")");
                    System.Threading.Thread.Sleep(250);
                }
            }
            if (!done)
            {
                System.Diagnostics.Debug.WriteLineIf(DEBUG, "rec: Could not get header");
                return false;
            }
            return true;
        }

        private byte[] CreatePacketFromMsg(RSProtoBuffSSHMsg msg)
        {
            byte[] a = new byte[4];
            byte[] pbMsg = new byte[msg.BodySize];
            byte[] output = new byte[16 + msg.BodySize];

            a = UintToByteNetwortOrder(msg.MagicCode);
            Array.Copy(a, 0, output, 0, 4);
            a = UintToByteNetwortOrder(msg.MsgID);
            Array.Copy(a, 0, output, 4, 4);
            a = UintToByteNetwortOrder(msg.ReqID);
            Array.Copy(a, 0, output, 8, 4);
            a = UintToByteNetwortOrder(msg.BodySize);
            Array.Copy(a, 0, output, 12, 4);

            msg.ProtoBuffMsg.Read(pbMsg, 0, (int)msg.BodySize);
            msg.ProtoBuffMsg.Position = 0;
            Array.Copy(pbMsg, 0, output, 16, (int)msg.BodySize);

            return output;
        }

        private byte[] UintToByteNetwortOrder(uint i)
        {
            byte[] a = new byte[4];
            a = BitConverter.GetBytes(i);
            Array.Reverse(a);
            return a;
        }

        public uint GetReqID()
        {
            if (_nextReqID < UInt32.MaxValue)
                return _nextReqID++;

            _nextReqID = 0; // else
            return _nextReqID;
        }

        // main loop
        private void mainLoop()
        {
            bool foundWork;
            while (_run)
            {
                foundWork = false;
                if (_sendQueue.Count > 0)
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "#######################################");
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: sending req");
                    RSProtoBuffSSHMsg msg = new RSProtoBuffSSHMsg();
                    lock (_sendQueue)
                        msg = _sendQueue.Dequeue();
                    Send(msg);
                    foundWork = true;
                }

                if (_stream.DataAvailable && _run && !_finishQueue)
                {
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "#######################################");
                    System.Diagnostics.Debug.WriteLineIf(DEBUG, "loop: receiving");
                    RSProtoBuffSSHMsg newMsg = new RSProtoBuffSSHMsg();
                    if (Receive(out newMsg))
                        lock (_receiveQueue)
                            _receiveQueue.Enqueue(newMsg);
                    foundWork = true;
                }

                if (!foundWork && _run && !_finishQueue)
                    System.Threading.Thread.Sleep(250);

                if (_finishQueue && _sendQueue.Count == 0)
                    _run = false;
            }
        }

        public void FinishQueue()
        {
            _finishQueue = true;
        }

        public void StopThread()
        {
            _run = false;
            _t.Abort();
        }

        // MsgID functions
        // Lower 8 bits.
        public static byte GetRpcMsgIdSubMsg(uint msgID)
        {
            return BitConverter.GetBytes(msgID)[0];
        }

        // Middle 16 bits.
        public static ushort GetRpcMsgIdService(uint msgID)
        {
            return BitConverter.ToUInt16(BitConverter.GetBytes(msgID), 1);
        }

        // Top 8 bits.
        public static byte GetRpcMsgIdExtension(uint msgID)
        {
            return (byte)(BitConverter.GetBytes(msgID)[3] & 0xFE);
            //return (msg_id >> 24) & 0xFE; // Bottom Bit is for Request / Response
        }

        public static bool IsRpcMsgIdResponse(uint msgID)
        {
            return ((BitConverter.GetBytes(msgID)[3] & 0x01) > 0 ? true : false);
            //return (msg_id >> 24) & 0x01;
        }

        public static uint ConstructMsgId(byte ext, ushort service, byte submsg, bool isResponse)
        {
            if (isResponse)
                ext |= 0x01; // Set Bottom Bit.
            else
                ext &= 0xFE; // Clear Bottom Bit.
            int msg_id = (ext << 24) + (service << 8) + (submsg);
            return Convert.ToUInt32(msg_id);
        }

        public static string GetHex(uint msgID)
        {
            return Convert.ToString(msgID, 16);
        }

        public static string GetHex(byte msgID)
        {
            return Convert.ToString(msgID, 16);
        }

        public static bool Deserialize<T>(Stream body, out T msg, out Exception e)
        {
            try
            {
                msg = Serializer.Deserialize<T>(body);
                e = null;
                return true;
            }
            catch (Exception exc)
            {
                e = exc;
                msg = default(T);
                return false;
            }
        }
    }
}
